// Package compiler implements the GoScript compiler
// It compiles AST nodes to bytecode instructions with key-based instruction management
package compiler

import (
	"fmt"
	"go/ast"
	"go/token"
	"strconv"

	"github.com/lengzhao/goscript/context"
	"github.com/lengzhao/goscript/instruction"
	"github.com/lengzhao/goscript/vm"
)

// FunctionInfo holds information about a compiled function
type FunctionInfo struct {
	Name         string
	Key          string // Unique key for the function (e.g., "main.function.block1")
	ParamCount   int
	ParamNames   []string
	ReceiverType string // "value" or "pointer"
	StartIP      int
	EndIP        int
}

// Compiler compiles AST nodes to bytecode with key-based instruction management
type Compiler struct {
	// Virtual machine to generate instructions for
	vm *vm.VM

	// Compile context for organizing instructions during compilation
	compileContext *context.CompileContext

	// Current compile context for the current scope
	currentCompileContext *context.CompileContext

	// Compiled functions map
	functionMap map[string]*FunctionInfo

	// Current scope key for generating unique keys
	currentScopeKey string

	// Counter for generating unique keys
	keyCounter int

	// Instructions for the current scope
	currentInstructions []*instruction.Instruction
}

// NewCompiler creates a new compiler with key-based instruction management
func NewCompiler(vmInstance *vm.VM) *Compiler {
	compileCtx := context.NewCompileContext("main", nil)
	return &Compiler{
		vm:                    vmInstance,
		compileContext:        compileCtx,
		currentCompileContext: compileCtx,
		functionMap:           make(map[string]*FunctionInfo),
		currentScopeKey:       "main",
		keyCounter:            0,
		currentInstructions:   make([]*instruction.Instruction, 0),
	}
}

// Compile compiles an AST file to bytecode with key-based instruction management
func (c *Compiler) Compile(file *ast.File) error {
	// Process all function declarations
	var mainFunc *ast.FuncDecl
	var otherFuncs []*ast.FuncDecl

	for _, decl := range file.Decls {
		if fn, ok := decl.(*ast.FuncDecl); ok {
			if fn.Name.Name == "main" {
				mainFunc = fn
			} else {
				otherFuncs = append(otherFuncs, fn)
			}
		}
	}

	// First pass: Create function info for all functions
	for _, fn := range otherFuncs {
		if err := c.createFunctionInfo(fn); err != nil {
			return err
		}
	}

	// Second pass: Register all functions
	for _, fn := range otherFuncs {
		if err := c.compileFunctionRegistration(fn); err != nil {
			return err
		}
	}

	// Third pass: Compile function bodies
	for _, fn := range otherFuncs {
		if err := c.compileFunctionBody(fn); err != nil {
			return err
		}
	}

	// Compile main function if it exists
	if mainFunc != nil {
		c.currentScopeKey = "main"
		if err := c.compileMainFunction(mainFunc); err != nil {
			return err
		}
	}

	// Transfer all compiled instructions to the VM
	return c.transferInstructions()
}

// createFunctionInfo creates function info for a function declaration
func (c *Compiler) createFunctionInfo(fn *ast.FuncDecl) error {
	funcName := fn.Name.Name
	fmt.Printf("Creating function info for: %s\n", funcName)

	// Check if this is a method (has receiver)
	var receiverTypeName string
	var receiverType string // "value" or "pointer"
	if fn.Recv != nil && len(fn.Recv.List) > 0 {
		// This is a method
		if len(fn.Recv.List) > 0 {
			receiver := fn.Recv.List[0]
			// Extract type name from receiver
			switch t := receiver.Type.(type) {
			case *ast.Ident:
				receiverTypeName = t.Name
				receiverType = "value"
			case *ast.StarExpr:
				if ident, ok := t.X.(*ast.Ident); ok {
					receiverTypeName = ident.Name
				}
				receiverType = "pointer"
			}
		}

		// Create unique method name
		if receiverTypeName != "" {
			funcName = receiverTypeName + "." + fn.Name.Name
		}

		fmt.Printf("Creating method info for: %s (unique name: %s, receiver type: %s)\n", fn.Name.Name, funcName, receiverType)
	} else {
		fmt.Printf("Creating function info for: %s\n", funcName)
	}

	// Create function info with a unique key
	funcInfo := &FunctionInfo{
		Name:         funcName,
		Key:          c.generateKey("func"),
		ParamCount:   0,
		ParamNames:   make([]string, 0),
		ReceiverType: receiverType,
	}

	// Handle receiver parameter for methods
	if fn.Recv != nil && len(fn.Recv.List) > 0 {
		receiver := fn.Recv.List[0]
		if len(receiver.Names) > 0 {
			// Add receiver name to parameter names
			funcInfo.ParamNames = append(funcInfo.ParamNames, receiver.Names[0].Name)
			funcInfo.ParamCount++
		}
	}

	// Count parameters and collect parameter names
	if fn.Type.Params != nil {
		// Count all parameter names (handling multiple names per field)
		for _, param := range fn.Type.Params.List {
			for _, name := range param.Names {
				funcInfo.ParamCount++
				funcInfo.ParamNames = append(funcInfo.ParamNames, name.Name)
			}
		}
	}

	// Store function info
	c.functionMap[funcName] = funcInfo
	return nil
}

// compileFunctionRegistration registers a function with the VM using its key
func (c *Compiler) compileFunctionRegistration(fn *ast.FuncDecl) error {
	// Get function name
	funcName := fn.Name.Name

	// Check if this is a method
	if fn.Recv != nil && len(fn.Recv.List) > 0 {
		// This is a method
		if len(fn.Recv.List) > 0 {
			receiver := fn.Recv.List[0]
			// Extract type name from receiver
			var receiverTypeName string
			switch t := receiver.Type.(type) {
			case *ast.Ident:
				receiverTypeName = t.Name
			case *ast.StarExpr:
				if ident, ok := t.X.(*ast.Ident); ok {
					receiverTypeName = ident.Name
				}
			}

			// Create unique method name
			if receiverTypeName != "" {
				funcName = receiverTypeName + "." + fn.Name.Name
			}
		}
	}

	fmt.Printf("Compiling function registration for: %s\n", funcName)

	// Get function info
	funcInfo, exists := c.functionMap[funcName]
	if !exists {
		return fmt.Errorf("function %s not found in function map", funcName)
	}

	// Create script function with key-based identification
	scriptFunc := &vm.ScriptFunction{
		Name:         funcName,
		Key:          funcInfo.Key,
		ParamCount:   funcInfo.ParamCount,
		ParamNames:   funcInfo.ParamNames,
		ReceiverType: funcInfo.ReceiverType,
	}

	// Register the script function with the VM
	c.vm.RegisterScriptFunction(funcName, scriptFunc)
	fmt.Printf("Registered script function: %s with key %s\n", funcName, funcInfo.Key)

	return nil
}

// compileFunctionBody compiles a function body and organizes instructions by key
func (c *Compiler) compileFunctionBody(fn *ast.FuncDecl) error {
	// Get function name
	funcName := fn.Name.Name

	// Check if this is a method
	if fn.Recv != nil && len(fn.Recv.List) > 0 {
		// This is a method
		if len(fn.Recv.List) > 0 {
			receiver := fn.Recv.List[0]
			// Extract type name from receiver
			var receiverTypeName string
			switch t := receiver.Type.(type) {
			case *ast.Ident:
				receiverTypeName = t.Name
			case *ast.StarExpr:
				if ident, ok := t.X.(*ast.Ident); ok {
					receiverTypeName = ident.Name
				}
			}

			// Create unique method name
			if receiverTypeName != "" {
				funcName = receiverTypeName + "." + fn.Name.Name
			}
		}
	}

	// Get existing function info
	funcInfo, exists := c.functionMap[funcName]
	if !exists {
		return fmt.Errorf("function %s not found in function map", funcName)
	}

	// Save current state
	prevScopeKey := c.currentScopeKey
	prevCompileContext := c.currentCompileContext
	prevInstructions := c.currentInstructions

	// Set the current scope key to the function's key
	c.currentScopeKey = funcInfo.Key

	// Create new compile context for the function
	funcCompileCtx := context.NewCompileContext(funcInfo.Key, c.compileContext)
	c.compileContext.AddChild(funcCompileCtx)
	c.currentCompileContext = funcCompileCtx
	c.currentInstructions = make([]*instruction.Instruction, 0)

	// Generate code to store parameters as local variables
	for i := len(funcInfo.ParamNames) - 1; i >= 0; i-- {
		paramName := funcInfo.ParamNames[i]
		// Pop parameter from stack and store as local variable
		c.emitInstruction(instruction.NewInstruction(instruction.OpCreateVar, paramName, nil))
		c.emitInstruction(instruction.NewInstruction(instruction.OpStoreName, paramName, nil))
	}

	// Compile the function body
	if err := c.compileBlockStmt(fn.Body); err != nil {
		// Restore previous state
		c.currentScopeKey = prevScopeKey
		c.currentCompileContext = prevCompileContext
		c.currentInstructions = prevInstructions
		return err
	}

	// Save function instructions with the function's key
	if len(c.currentInstructions) > 0 {
		c.currentCompileContext.SetInstructions(funcInfo.Key, c.currentInstructions)
	}

	// Update function info with IP range
	funcInfo.StartIP = 0 // Will be updated during transfer
	funcInfo.EndIP = len(c.currentInstructions)

	// Restore previous state
	c.currentScopeKey = prevScopeKey
	c.currentCompileContext = prevCompileContext
	c.currentInstructions = prevInstructions

	return nil
}

// compileMainFunction compiles the main function
func (c *Compiler) compileMainFunction(fn *ast.FuncDecl) error {
	// Save current state
	prevScopeKey := c.currentScopeKey
	prevCompileContext := c.currentCompileContext
	prevInstructions := c.currentInstructions

	// Set the current scope key to main
	c.currentScopeKey = "main"

	// Create new compile context for main
	mainCompileCtx := context.NewCompileContext("main", c.compileContext)
	c.compileContext.AddChild(mainCompileCtx)
	c.currentCompileContext = mainCompileCtx
	c.currentInstructions = make([]*instruction.Instruction, 0)

	// Compile the main function body
	if err := c.compileBlockStmt(fn.Body); err != nil {
		// Restore previous state
		c.currentScopeKey = prevScopeKey
		c.currentCompileContext = prevCompileContext
		c.currentInstructions = prevInstructions
		return err
	}

	// Save main instructions
	if len(c.currentInstructions) > 0 {
		c.currentCompileContext.SetInstructions("main", c.currentInstructions)
	}

	// Restore previous state
	c.currentScopeKey = prevScopeKey
	c.currentCompileContext = prevCompileContext
	c.currentInstructions = prevInstructions

	return nil
}

// compileBlockStmt compiles a block statement with key-based scope management
func (c *Compiler) compileBlockStmt(block *ast.BlockStmt) error {
	// Generate a unique scope key for this block
	scopeKey := c.generateKey("block")

	// Enter the new scope
	c.enterScope(scopeKey)

	// Emit instruction to enter the block scope
	c.emitInstruction(instruction.NewInstruction(instruction.OpEnterScopeWithKey, scopeKey, nil))

	// Compile each statement in the block
	for _, stmt := range block.List {
		if err := c.compileStmt(stmt); err != nil {
			c.exitScope()
			return err
		}
	}

	// Emit instruction to exit the block scope
	c.emitInstruction(instruction.NewInstruction(instruction.OpExitScopeWithKey, scopeKey, nil))

	// Exit the scope
	c.exitScope()

	return nil
}

// compileStmt compiles a statement
func (c *Compiler) compileStmt(stmt ast.Stmt) error {
	switch s := stmt.(type) {
	case *ast.ExprStmt:
		return c.compileExprStmt(s)
	case *ast.AssignStmt:
		return c.compileAssignStmt(s)
	case *ast.ReturnStmt:
		return c.compileReturnStmt(s)
	case *ast.IfStmt:
		return c.compileIfStmt(s)
	case *ast.ForStmt:
		return c.compileForStmt(s)
	case *ast.BlockStmt:
		return c.compileBlockStmt(s)
	case *ast.IncDecStmt:
		return c.compileIncDecStmt(s)
	default:
		return fmt.Errorf("unsupported statement type: %T", stmt)
	}
}

// compileExprStmt compiles an expression statement
func (c *Compiler) compileExprStmt(stmt *ast.ExprStmt) error {
	return c.compileExpr(stmt.X)
}

// compileAssignStmt compiles an assignment statement
func (c *Compiler) compileAssignStmt(stmt *ast.AssignStmt) error {
	// Handle different assignment operators
	switch stmt.Tok {
	case token.ASSIGN, token.DEFINE:
		// Handle = and := operators
		// Compile the right-hand side expression
		err := c.compileExpr(stmt.Rhs[0])
		if err != nil {
			return err
		}

		// Handle the left-hand side
		if lhs, ok := stmt.Lhs[0].(*ast.Ident); ok {
			// For short variable declaration (:=), create the variable first
			if stmt.Tok == token.DEFINE {
				c.emitInstruction(instruction.NewInstruction(instruction.OpCreateVar, lhs.Name, nil))
			}
			// Store the result in the variable
			c.emitInstruction(instruction.NewInstruction(instruction.OpStoreName, lhs.Name, nil))
		}
	case token.ADD_ASSIGN:
		// Handle += operator
		// First load the current value of the variable
		switch lhs := stmt.Lhs[0].(type) {
		case *ast.Ident:
			c.emitInstruction(instruction.NewInstruction(instruction.OpLoadName, lhs.Name, nil))
		default:
			return fmt.Errorf("unsupported assignment target for +=: %T", lhs)
		}

		// Compile the right-hand side expression
		err := c.compileExpr(stmt.Rhs[0])
		if err != nil {
			return err
		}

		// Add the values
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpAdd, nil))

		// Store the result back
		switch lhs := stmt.Lhs[0].(type) {
		case *ast.Ident:
			c.emitInstruction(instruction.NewInstruction(instruction.OpStoreName, lhs.Name, nil))
		}
	case token.SUB_ASSIGN:
		// Handle -= operator
		// First load the current value of the variable
		switch lhs := stmt.Lhs[0].(type) {
		case *ast.Ident:
			c.emitInstruction(instruction.NewInstruction(instruction.OpLoadName, lhs.Name, nil))
		default:
			return fmt.Errorf("unsupported assignment target for -=: %T", lhs)
		}

		// Compile the right-hand side expression
		err := c.compileExpr(stmt.Rhs[0])
		if err != nil {
			return err
		}

		// Subtract the values
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpSub, nil))

		// Store the result back
		switch lhs := stmt.Lhs[0].(type) {
		case *ast.Ident:
			c.emitInstruction(instruction.NewInstruction(instruction.OpStoreName, lhs.Name, nil))
		}
	case token.MUL_ASSIGN:
		// Handle *= operator
		// First load the current value of the variable
		switch lhs := stmt.Lhs[0].(type) {
		case *ast.Ident:
			c.emitInstruction(instruction.NewInstruction(instruction.OpLoadName, lhs.Name, nil))
		default:
			return fmt.Errorf("unsupported assignment target for *=: %T", lhs)
		}

		// Compile the right-hand side expression
		err := c.compileExpr(stmt.Rhs[0])
		if err != nil {
			return err
		}

		// Multiply the values
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpMul, nil))

		// Store the result back
		switch lhs := stmt.Lhs[0].(type) {
		case *ast.Ident:
			c.emitInstruction(instruction.NewInstruction(instruction.OpStoreName, lhs.Name, nil))
		}
	case token.QUO_ASSIGN:
		// Handle /= operator
		// First load the current value of the variable
		switch lhs := stmt.Lhs[0].(type) {
		case *ast.Ident:
			c.emitInstruction(instruction.NewInstruction(instruction.OpLoadName, lhs.Name, nil))
		default:
			return fmt.Errorf("unsupported assignment target for /=: %T", lhs)
		}

		// Compile the right-hand side expression
		err := c.compileExpr(stmt.Rhs[0])
		if err != nil {
			return err
		}

		// Divide the values
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpDiv, nil))

		// Store the result back
		switch lhs := stmt.Lhs[0].(type) {
		case *ast.Ident:
			c.emitInstruction(instruction.NewInstruction(instruction.OpStoreName, lhs.Name, nil))
		}
	case token.REM_ASSIGN:
		// Handle %= operator
		// First load the current value of the variable
		switch lhs := stmt.Lhs[0].(type) {
		case *ast.Ident:
			c.emitInstruction(instruction.NewInstruction(instruction.OpLoadName, lhs.Name, nil))
		default:
			return fmt.Errorf("unsupported assignment target for %=: %T", lhs)
		}

		// Compile the right-hand side expression
		err := c.compileExpr(stmt.Rhs[0])
		if err != nil {
			return err
		}

		// Modulo the values
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpMod, nil))

		// Store the result back
		switch lhs := stmt.Lhs[0].(type) {
		case *ast.Ident:
			c.emitInstruction(instruction.NewInstruction(instruction.OpStoreName, lhs.Name, nil))
		}
	default:
		return fmt.Errorf("unsupported assignment operator: %s", stmt.Tok)
	}

	return nil
}

// compileReturnStmt compiles a return statement
func (c *Compiler) compileReturnStmt(stmt *ast.ReturnStmt) error {
	// If there are return values, compile them
	if len(stmt.Results) > 0 {
		if err := c.compileExpr(stmt.Results[0]); err != nil {
			return err
		}
	} else {
		// If no return value, return nil
		c.emitInstruction(instruction.NewInstruction(instruction.OpLoadConst, nil, nil))
	}

	// Emit return instruction
	c.emitInstruction(instruction.NewInstruction(instruction.OpReturn, nil, nil))
	return nil
}

// compileIfStmt compiles an if statement
func (c *Compiler) compileIfStmt(stmt *ast.IfStmt) error {
	// Compile the condition
	if err := c.compileExpr(stmt.Cond); err != nil {
		return err
	}

	// Emit a conditional jump instruction (placeholder target)
	jumpIfInstr := instruction.NewInstruction(instruction.OpJumpIf, 0, nil) // Placeholder target
	c.emitInstruction(jumpIfInstr)

	// Compile the if body
	if err := c.compileBlockStmt(stmt.Body); err != nil {
		return err
	}

	// If there's an else block, we need to jump over it at the end of the if block
	var elseJumpInstr *instruction.Instruction
	if stmt.Else != nil {
		// Emit an unconditional jump to skip the else block
		elseJumpInstr = instruction.NewInstruction(instruction.OpJump, 0, nil) // Placeholder target
		c.emitInstruction(elseJumpInstr)
	}

	// Update the conditional jump target to after the if body
	jumpIfInstr.Arg = len(c.currentInstructions)

	// Compile the else block if it exists
	if stmt.Else != nil {
		if elseStmt, ok := stmt.Else.(*ast.BlockStmt); ok {
			if err := c.compileBlockStmt(elseStmt); err != nil {
				return err
			}
			// Update the else jump target to after the else block
			elseJumpInstr.Arg = len(c.currentInstructions)
		}
	}

	return nil
}

// compileForStmt compiles a for statement
func (c *Compiler) compileForStmt(stmt *ast.ForStmt) error {
	// Compile the init statement if it exists
	if stmt.Init != nil {
		if err := c.compileStmt(stmt.Init); err != nil {
			return err
		}
	}

	// Save the start IP for looping
	startIP := len(c.currentInstructions)

	// Compile the condition if it exists
	if stmt.Cond != nil {
		if err := c.compileExpr(stmt.Cond); err != nil {
			return err
		}

		// Emit a conditional jump to exit the loop
		jumpIfInstr := instruction.NewInstruction(instruction.OpJumpIf, 0, nil) // Placeholder target
		c.emitInstruction(jumpIfInstr)

		// Compile the loop body
		if err := c.compileBlockStmt(stmt.Body); err != nil {
			return err
		}

		// Compile the post statement if it exists
		if stmt.Post != nil {
			if err := c.compileStmt(stmt.Post); err != nil {
				return err
			}
		}

		// Emit an unconditional jump back to the start
		c.emitInstruction(instruction.NewInstruction(instruction.OpJump, startIP, nil))

		// Update the conditional jump target to after the loop
		jumpIfInstr.Arg = len(c.currentInstructions)
	} else {
		// Infinite loop - compile the body
		if err := c.compileBlockStmt(stmt.Body); err != nil {
			return err
		}

		// Compile the post statement if it exists
		if stmt.Post != nil {
			if err := c.compileStmt(stmt.Post); err != nil {
				return err
			}
		}

		// Emit an unconditional jump back to the start
		c.emitInstruction(instruction.NewInstruction(instruction.OpJump, startIP, nil))
	}

	return nil
}

// compileIncDecStmt compiles an increment or decrement statement
func (c *Compiler) compileIncDecStmt(stmt *ast.IncDecStmt) error {
	// Compile the expression
	err := c.compileExpr(stmt.X)
	if err != nil {
		return err
	}

	// Emit the appropriate instruction
	if stmt.Tok == token.INC {
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpAdd, 1))
	} else if stmt.Tok == token.DEC {
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpSub, 1))
	}

	// Store the result back
	switch x := stmt.X.(type) {
	case *ast.Ident:
		c.emitInstruction(instruction.NewInstruction(instruction.OpStoreName, x.Name, nil))
	default:
		return fmt.Errorf("unsupported increment/decrement target: %T", x)
	}

	return nil
}

// compileExpr compiles an expression
func (c *Compiler) compileExpr(expr ast.Expr) error {
	switch e := expr.(type) {
	case *ast.BasicLit:
		return c.compileBasicLit(e)
	case *ast.BinaryExpr:
		return c.compileBinaryExpr(e)
	case *ast.CallExpr:
		return c.compileCallExpr(e)
	case *ast.Ident:
		return c.compileIdent(e)
	case *ast.ParenExpr:
		return c.compileExpr(e.X)
	default:
		return fmt.Errorf("unsupported expression type: %T", expr)
	}
}

// compileBasicLit compiles a basic literal
func (c *Compiler) compileBasicLit(lit *ast.BasicLit) error {
	switch lit.Kind {
	case token.INT:
		// Parse the integer value
		value, err := strconv.Atoi(lit.Value)
		if err != nil {
			return err
		}
		c.emitInstruction(instruction.NewInstruction(instruction.OpLoadConst, value, nil))
	case token.FLOAT:
		// Parse the float value
		value, err := strconv.ParseFloat(lit.Value, 64)
		if err != nil {
			return err
		}
		c.emitInstruction(instruction.NewInstruction(instruction.OpLoadConst, value, nil))
	case token.STRING:
		// Remove quotes from string literal
		value := lit.Value[1 : len(lit.Value)-1]
		c.emitInstruction(instruction.NewInstruction(instruction.OpLoadConst, value, nil))
	default:
		return fmt.Errorf("unsupported literal kind: %s", lit.Kind)
	}
	return nil
}

// compileBinaryExpr compiles a binary expression
func (c *Compiler) compileBinaryExpr(expr *ast.BinaryExpr) error {
	// Compile left operand
	if err := c.compileExpr(expr.X); err != nil {
		return err
	}

	// Compile right operand
	if err := c.compileExpr(expr.Y); err != nil {
		return err
	}

	// Emit the appropriate binary operation
	switch expr.Op {
	case token.ADD:
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpAdd, nil))
	case token.SUB:
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpSub, nil))
	case token.MUL:
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpMul, nil))
	case token.QUO:
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpDiv, nil))
	case token.REM:
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpMod, nil))
	case token.EQL:
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpEqual, nil))
	case token.NEQ:
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpNotEqual, nil))
	case token.LSS:
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpLess, nil))
	case token.LEQ:
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpLessEqual, nil))
	case token.GTR:
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpGreater, nil))
	case token.GEQ:
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpGreaterEqual, nil))
	case token.LAND:
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpAnd, nil))
	case token.LOR:
		c.emitInstruction(instruction.NewInstruction(instruction.OpBinaryOp, instruction.OpOr, nil))
	default:
		return fmt.Errorf("unsupported binary operator: %s", expr.Op)
	}

	return nil
}

// compileCallExpr compiles a function call expression with key-based calling
func (c *Compiler) compileCallExpr(expr *ast.CallExpr) error {
	// Handle regular function calls
	ident, ok := expr.Fun.(*ast.Ident)
	if !ok {
		return fmt.Errorf("unsupported function call type: %T", expr.Fun)
	}

	// Compile all arguments
	argCount := len(expr.Args)
	for _, arg := range expr.Args {
		if err := c.compileExpr(arg); err != nil {
			return err
		}
	}

	// Emit the function call instruction with key-based calling
	// For script functions, we use the key to identify them
	if funcInfo, exists := c.functionMap[ident.Name]; exists {
		// This is a script function, use OpCall with the function key
		c.emitInstruction(instruction.NewInstruction(instruction.OpCall, funcInfo.Key, argCount))
	} else {
		// This is an external function, use the function name
		c.emitInstruction(instruction.NewInstruction(instruction.OpCall, ident.Name, argCount))
	}

	return nil
}

// compileIdent compiles an identifier
func (c *Compiler) compileIdent(ident *ast.Ident) error {
	// Emit a load name instruction
	c.emitInstruction(instruction.NewInstruction(instruction.OpLoadName, ident.Name, nil))
	return nil
}

// generateKey generates a unique key for a code block
func (c *Compiler) generateKey(prefix string) string {
	c.keyCounter++
	return fmt.Sprintf("%s.%s_%d", c.currentScopeKey, prefix, c.keyCounter)
}

// emitInstruction adds an instruction to the current scope
func (c *Compiler) emitInstruction(instr *instruction.Instruction) {
	c.currentInstructions = append(c.currentInstructions, instr)
}

// enterScope enters a new scope with the given key
func (c *Compiler) enterScope(key string) {
	// Save current instructions to the current compile context
	if len(c.currentInstructions) > 0 {
		c.currentCompileContext.SetInstructions(c.currentScopeKey, c.currentInstructions)
	}

	// Create new compile context for the new scope
	newCtx := context.NewCompileContext(key, c.currentCompileContext)
	c.currentCompileContext.AddChild(newCtx)
	c.currentCompileContext = newCtx
	c.currentScopeKey = key
	c.currentInstructions = make([]*instruction.Instruction, 0)
}

// exitScope exits the current scope and returns to the parent scope
func (c *Compiler) exitScope() {
	// Save current instructions to the current compile context
	if len(c.currentInstructions) > 0 {
		c.currentCompileContext.SetInstructions(c.currentScopeKey, c.currentInstructions)
	}

	// Return to parent context
	if c.currentCompileContext.GetParent() != nil {
		c.currentCompileContext = c.currentCompileContext.GetParent()
		c.currentScopeKey = c.currentCompileContext.GetPathKey()
		// Retrieve instructions for the parent scope
		if instructions, exists := c.currentCompileContext.GetInstructions(c.currentScopeKey); exists {
			c.currentInstructions = instructions
		} else {
			c.currentInstructions = make([]*instruction.Instruction, 0)
		}
	}
}

// transferInstructions transfers all compiled instructions from the compile context to the VM
func (c *Compiler) transferInstructions() error {
	// Transfer instructions from the main compile context
	if err := c.transferContextInstructions(c.compileContext); err != nil {
		return err
	}
	return nil
}

// transferContextInstructions recursively transfers instructions from a compile context to the VM
func (c *Compiler) transferContextInstructions(ctx *context.CompileContext) error {
	// Get all instructions from this context
	instructions := ctx.GetAllInstructions()

	// Transfer each set of instructions
	for key, instrs := range instructions {
		fmt.Printf("Transferring instructions for key: %s, count: %d\n", key, len(instrs))

		// For function instructions, we need to register them with the VM
		if len(key) >= 4 && key[len(key)-4:len(key)] == "func" {
			// Find the corresponding function info
			for funcName, funcInfo := range c.functionMap {
				if funcInfo.Key == key {
					// Register the function with the VM
					startIP := len(c.vm.GetInstructions())

					// Add all instructions to the VM
					for _, instr := range instrs {
						c.vm.AddInstruction(instr)
					}

					endIP := len(c.vm.GetInstructions())

					// Update the script function info with the actual IP range
					scriptFunc := &vm.ScriptFunction{
						Name:         funcName,
						Key:          key,
						StartIP:      startIP,
						EndIP:        endIP,
						ParamCount:   funcInfo.ParamCount,
						ParamNames:   funcInfo.ParamNames,
						ReceiverType: funcInfo.ReceiverType,
					}

					// Re-register the script function with updated IP range
					c.vm.RegisterScriptFunction(funcName, scriptFunc)
					fmt.Printf("Registered function %s with IP range [%d, %d)\n", funcName, startIP, endIP)
					break
				}
			}
		} else {
			// For non-function instructions (main code), add them directly to the VM
			for _, instr := range instrs {
				c.vm.AddInstruction(instr)
			}
		}
	}

	// Recursively transfer instructions from child contexts
	children := ctx.GetChildren()
	for _, child := range children {
		if err := c.transferContextInstructions(child); err != nil {
			return err
		}
	}

	return nil
}
